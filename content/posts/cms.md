---
title: "对graphql服务优化，提高availability的一些思考"
date: 2022-03-23T10:27:22+11:00
draft: true
summary: 上周一个重要的graphql服务器因为访问量突然放大，造成一段时间依赖该服务的网页无法正常打开。这个服务运行在一个ec2 instance上面，数据储存在rds中，之前经过调查主要的瓶颈存在于cpu。
---

上周一个重要的graphql服务器因为访问量突然放大，造成一段时间依赖该服务的网页无法正常打开。这个服务运行在一个ec2 instance上面，数据储存在rds中，之前经过调查主要的瓶颈存在于cpu。因为框架的特点，一个graphql query会产生不少db的读取，然后在应用中拼装资料在返回给client。处理拼装这一步非常耗cpu, 而且随着db数据量的增大，压力也变得越来越大。其实之前这个服务就做了一系列的优化，不过在介绍优化前，还是有必要梳理总结一下目前的该服务的架构。

首先这个服务主要是用于文章管理，并对外提供graphql api接口，使用的是strapi框架搭建的。使用该接口的是一个相对静态的新闻网站，该网站使用nuxt框架搭建。strapi这个框架是node.js headless cms, 功能强大，可以非常容易的搭建一个灵活cms,而且容易扩展。当然这也是有代价的，因为功能强大，他对cpu的要求比较高，一开始数据量小的时候不明显，之后数据量上去后弊端就显示出来了。一开始对strapi框架并不熟悉，只是简单的提高ec2 instance的配置，从micro到small,然后在到medium，总是平息一段时日，之后又出现访问变慢的情况。后来一想一个相对静态的新闻类网站，却出现消耗如此多资源的情况，实在说不过去。于是开始考虑优化，并主要从静态化的角度入手。最开始的一个优化并没有直接在cms这个服务上，而是通过给其使用者nuxt框架添加server render的模块，进行访问页面的缓存。这一个优化的效果是不错，大大减轻了cms的访问量。但是这个优化也有不足的地方，一是不能灵活的控制缓存的时间，为了保证时效性，缓存时间不能设置的过长，二是无法解决直接访问graphql服务的情况。为了进一步优化，于是在graphql服务这块也添加的缓存机制，也是通过增加一个graphql cache的模块，同时增加的缓存失效的机制，当管理员添加或者修改文章时，将会是缓存失效。添加这个缓存之后，服务器的压力又小了许多，平均响应速度也提高了不少。按道理说，这样的缓存下，服务已经向静态化迈进了不少，但是结果上周的访问量突增还是让graphql的服务出现无法应对的情况。

对于事故的分析，我认为主要两个方面可以考虑。一是目前的静态化依然不够彻底，虽然有两层缓存，但是还是停留在只有用户访问才缓存的阶段。二是整个计算服务不够弹性化，不能够动态的伸缩，而且缺少相应的监控。


针对第一点，我的想法是进一步提高静态化的程度，争取做到管理员在保存文章的时候就进行缓存，而不是完全被动等待用户访问。要做到这点，就要提前知道用户访问时query的参数并以此作为key去缓存管理员保存的文章资料。因为article的网页地址都是相对固定，所以这个key是好预测的。还有一种方法就是利用网关去进行cache，虽然是graphql的api，但是网页地址是可以一一对应相应的graphql api的，所以网页地址可以作为key来进行缓存，比如构造一个referee header作为key的请求。


第二点是将graphql的服务从ec2服务器迁移到kubernetes上面，添加监控，并使其服务可以根据访问量动态伸缩。如果有需要还可以添加一个网关，来对访问进行进一步的缓存，并且增加rate limit的限制。网关这块我比较了一些比较常见的，有传统的nginx, 也有aws自带的apigateway, 还有比较新的kratos和kong等框架。nginx我是比较熟悉的，之前配置的不少网关都是使用nginx，我甚至度过nginx的源码，知道nginx的大致工作流程。nginx的效能很好，甚至有不少在nginx基础上改版的网关，比如tengine等等。应该说使用nginx作为网关是很可靠，而且我也有相关经验，但是nginx的代码量比较庞大，而且扩展起来也相对麻烦。aws的apigateway功能也很强大，身份验证，缓存，监控，lifecycle等等功能都有，而且和其他aws的服务有很好的整合，可惜并不开源。kratos是一个go语言写的网关框架，我之前就早有耳闻，功能强大，而且里面很多有意思的设计，包括使用api来动态配置网关等等，应该是学起来最有趣的一个。而Kong主要是lua语言写，并以nginx的基础上实现的一个网关，功能强大不说，而且支持kubernetes，在kubernetes上部署非常简单。

