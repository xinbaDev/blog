---
Title: "Uber's Study on Data Race Patterns in Go"
Date: 2022-07-17T10:27:22+11:00
Draft: False
Summary: While browsing through Uber's technology blog recently, I came across an interesting article titled "Data Race Patterns in Go." The article categorizes common instances of data races that occur in all of Uber's Go projects. Data races are not unfamiliar to me, as mishandling concurrent reads and writes to the same data can lead to data races. I have heard that Go has issues with data races, but I haven't seen any specific examples until now. Additionally, Uber is a large company with many Go projects, including the open-source Zap project and the previously mentioned Jaeger distributed monitoring project, so they likely have a lot of experience with Go. Therefore, I am interested in Uber's analysis based on their own experience with Go projects.
---

Recently, while browsing the Uber technology blog, I came across an interesting article titled "Data Race Pattern in Go". The article classifies data race situations that are easy to occur in all of Uber's GO projects. I am familiar with data race, which can occur when reading and writing to the same data concurrently if not handled properly. I had heard that Go has data race issues, but I didn't have a clear example. Moreover, Uber is a large company, and I remember that many of its projects, such as the open-source project Zap and the distributed monitoring project Jaeger, are written in Go. So, I was interested in Uber's analysis of its actual Go projects.

This time, Uber summarized seven major situations/classifications that are prone to data races. Here, I will briefly introduce some data races that I am interested in. In the first category, the index variable in the loop is not properly privatized. Specifically, calling a go routine inside a loop and then using the index variable in the go routine is a common mistake. There are also some interesting data races, such as assuming that maps are thread-safe because map operations appear to be simple assignments/reads. However, assigning a value to a key in a map can affect other keys in the same map, leading to data races. Therefore, using a map in multi-threading requires locking. In addition, incorrect use of add/done functions in sync.WaitGroup can also lead to data races.

In general, calling go routines in loops requires great caution, otherwise data races are likely to occur. The author also did some statistics, and the most common type of data race is concurrent slice access. Specifically, accessing a slice without locking in a multi-concurrency situation. A slice is a special type of data structure, and its metadata is copied to the stack when passed, rather than just passing a pointer. This can also cause data races. Another noteworthy situation that can cause data races is passing a mutex incorrectly. If a reference should be passed, but a value is passed instead, this can also cause data races. Due to Go's design, this type of incorrect passing is also considered valid. This situation does not occur in Rust.

In summary, there are many opportunities for data races to occur in Go, and some are not easy to detect, especially when rushing to write code. After an error occurs, data race errors are not easy to detect, and they may not appear immediately at runtime. Fixing them is very troublesome. Rust is much stronger in this regard because its design is aimed at avoiding data race situations. If there is code that may produce data races, it will not even compile. Of course, writing Rust code may not be as enjoyable as writing Go code because it requires considering memory-related issues while writing application logic. On the other hand, writing Go code is not as enjoyable as writing Python code because it requires considering variable types. It can be seen that programming languages are becoming increasingly abstract from the beginning, and there is a trend in recent years toward a return to the lower-level languages like C. Even Linux is considering rewriting the operating system in Rust.