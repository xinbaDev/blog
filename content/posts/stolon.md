---
title: "读stolon的源代码的一些收获"
date: 2022-06-20T21:16:11+11:00
summary: 最近因为工作方面的需要，接触到了一个叫stolon的工具。这个工具是用来管理postgres集群的，主要起到保证可用性和可维护性的作用。代码是用go写的，距今已经有6，7年的时间了。主要代码几乎就是一个人写的，总commit也不多，正好我对这一块有兴趣，于是抽了些时间来看了一下。
draft: true
---

最近因为工作方面的需要，接触到了一个叫stolon的工具。这个工具是用来管理postgres集群的，主要起到保证可用性和可维护性的作用。代码是用go写的，距今已经有6，7年的时间了。主要代码几乎就是一个人写的，总commit也不多，正好我对这一块有兴趣，于是抽了些时间来看了一下。

## stolon的架构

stolon的架构其实并不复杂，比起之前的分析forta，stolon架构其实更加简单。主要组成部分甚至从第一个commit就已经确定下来了，其中主要有三个，分别是keeper, proxy以及sentinel。keeper就是运行和控制postgres的程序，proxy则是client连接db的中介代理，而sentinel则是监控保证db集群正常运行的哨兵。其实还有一个重要的部分就是store, 主要是一个key value storage, 用来储存cluster的数据，会被keeper, proxy，sentinel用到。这个架构本身并不复杂，不过设计上挺有意思的，让我联想到设计模式里面的观察者模式。其中sentinel会周期性的查看db的状态，比如master db如果出了问题，那么sentinel就会通过getBestSlave的函数确定一个slave作为新的master，但是sentinel不会直接操作postgres，而是去改变store的值从而达到间接改变postgrea集群的目的。keeper和proxy则会监听store的变化，并进行动态的调整，比如keeper对postgres slave进行promote，proxy的destip改变成新的master db的ip等等。通过这种方式来达到数据库集群的可用性。这种设计模式的好处是，keepers,proxy和sentinel这3个组件权责分配清晰，可以很容易的扩容，非常灵活。

## 一些感想

老实说，stolon的代码质量我认为并不高，里面没有代码没有很好的分类，可以看到一个文件几千行的，或者一个函数几百行的，看起来并不舒服。还有就是一些不好命名习惯，作者喜欢用缩写，常常可以看到一些单个字母的变量。要不是因为我对这个工具感兴趣，想了解其中的工作原理，我可能看到这种代码就放弃了。还好这个代码量还不算大，而且整体结构还是比较清晰的，所以看了下来。我认为我已经把里面最关键的部分看到了，基本弄清楚了他的设计思路和工作原理，包括主要组件和功能以及他们之间是如何协作的。回顾一下这种架构还是挺有趣的，每一个组件都只需要知道自己需要负责的东西，然后自己(keepers,proxy)去看任务版。而sentinel则是去发布任务，本身不需要知道怎么去完成任务和给谁发任务，只要知道什么时候和如何发布任务就行。

其实stolon的这种架构还让我想起来kubernetes。虽然我并没有读过kubernetes的源码，但我明显感觉到其中的联系。像kubernetes也是通过类似的方式进行管理和保证可靠性的。不过kubernetes更进一步，发展出一套配置方式通过描述性的yaml文件来控制，而不需要通过cli的方式去控制集群。其实stolon也可以这么做，而且我估计应该已经有类似的项目了。通览整个源代码，可以发现不少TODO，但是都没有填上，估计是有类似的项目已经在做了吧。

除了这种观察者模式的架构设计之外，postgres集群的master/slave的变换也是我重点关注的，甚至是我当初决定阅读stolon代码的原因。在工作中我虽然用到了postgres的集群，但是aws的rds服务已经做了很多活，我本身并不用去管理集群的可靠性。但是我一直好奇这块是怎么做到高可靠的，中间又涉及到哪些流程。通过阅读stolon的代码让我大致有了一个了解。还有就是在升级迁移数据库的时候，我经常想有没有办法可以做到用户无感，但是总觉得情况比较复杂，最后安全起见都是乖乖挂维护公告，然后关闭数据库进行升级。在stolon中，为了实现数据的一致性，也选择牺牲一定程度的可靠性，也就是有可能会有一段时间的downtime。不过我想如果在proxy那边加上retry的机制或者配合其他带有retry功能的工具是不是就可以在一定程度上解决这个问题？我觉得这也许是一个解决的方法。查了一下，postgres相关的管理开源工具非常得多，https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling， 也许可以找个时间研究一下。

