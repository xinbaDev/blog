---
title: "Debugging and Optimization of SQL (Postgres query planner)"
date: 2023-06-13T19:33:00+11:00
summary: Recently, I encountered a very interesting SQL problem at work. The same raw SQL query took significantly different execution times. Through debugging and research of this problem, I gained a deeper understanding of the SQL execution process (Postgres) and corresponding optimization techniques.
draft: false
---

Recently, I encountered an interesting SQL problem at work. Almost the same raw SQL resulted in execution times that differed by more than a hundredfold. 

The problematic raw SQL (simplified for readability) is as follows:
```
# Returns the price data for all popular stocks from 10am (opening) to 4pm (closing).
SELECT "marketdata"."id", 
       "marketdata"."code_id", 
       "marketdata"."date",  
       "marketdata"."price",  
FROM "marketdata" INNER JOIN "stock" ON 
("marketdata"."code_id" = "stock"."code") 
WHERE (
    "stock"."is_hot" = true AND 
    "marketdata"."date" BETWEEN 'XXXX-XX-XXT10:00:00' AND 'XXXX-XX-XXT16:00:00') 
ORDER BY "marketdata"."date" ASC
```

## 0x01 Background

Our company mainly focuses on researching and analyzing Australian stock market information, including publishing prices, trends, announcements, and other important market information for all stocks listed on the Australian Securities Exchange (ASX). Recently, due to project requirements, we added a new category for stocks called "special".

Previously, there were already many categories, such as popular stocks, gold mining stocks, etc. So adding a new category was not something new. All we had to do was to add a category to the stock table in the database (by adding an "is_special" column to the stock schema) and then add an "is_special" filter to the corresponding API. However, this seemingly simple requirement taught me a lot of things :)

As soon as the new feature was deployed to the staging environment, we found that the response time of the corresponding API was much longer than that of other APIs of the same type. The normal APIs returned responses in less than 1 second, but this new API required a shocking 30-40 seconds, or even timed out. However, there was no problem when testing locally. We quickly ran a git diff command to confirm that there were no basic code logic errors. We soon ruled out code issues that could cause long responses (as there were very few changes), but during a quick code review, we noticed that whenever the cache expired, the API would read the corresponding data from the database and write it to the cache. Based on the previous test results, we immediately suspected that there was a problem on the database side. We looked at the AWS monitor and found that the number of database reads had skyrocketed since the deployment, confirming that there was a problem on the database side. My first guess was that an index was missing, but that was quickly ruled out after inspection. Later, using some debugging tools, we obtained the raw SQL generated by the ORM (as shown above). We found that is_hot was working normally, but is_special was very slow. Thus, the cause of the problem had been narrowed down to a relatively small scope, and the variable that could cause the error had been greatly reduced. The remaining problem was:

Why is "is_special" so slow compared to "is_hot"?
    
## 0x02 Preliminary Analysis of Slow DB Queries

First, let's take a look at what is different between these two queries. At first glance, it's just that "is_hot" has been changed to "is_special". However, at the database level, the DB will read all stocks where "is_special" or "is_hot" is true. "is_special" is a new category with only two stocks, so reading all the data will only result in 360 (the number of price data entries per day) * 2 = 720 rows. On the other hand, "is_hot" represents popular stocks, which there are hundreds of, resulting in 360 × 100 = 36,000 rows. Why is it that the SQL query with the larger amount of data actually executes faster than the one with the smaller amount of data, despite the fact that they are essentially the same query?

This has to do with how Postgres executes this SQL statement. As we have previously learned, the most important step in the database's processing of a query is planning. In the case of Postgres, when the DB receives an SQL query, it will estimate the time required for all possible combinations of query execution plans (such as how to scan, how to join, how to order) based on some previous statistical data, and then find the execution plan that requires the least amount of time, and then execute it. How can we check how the DB estimates and finds the optimal solution? Postgres has a command called EXPLAIN ANALYZE.

Next, let's take a look at how these two "sibling" queries are executed in the DB.
First take a look at "is_hot"
```
Sort  (cost=119007.54..119066.60 rows=23621 width=241) (actual time=116.795..127.942 rows=37125 loops=1)"
  Sort Key: marketdata.date"
  Sort Method: external merge  Disk: 4800kB"
  ->  Nested Loop  (cost=24.31..114544.24 rows=23621 width=241) (actual time=0.185..73.446 rows=37125 loops=1)"
        ->  Seq Scan on stock  (cost=0.00..441.12 rows=100 width=4) (actual time=0.066..1.211 rows=100 loops=1)"
              Filter: is_hot"
              Rows Removed by Filter: 2492"
        ->  Bitmap Heap Scan on marketdata  (cost=24.31..1138.09 rows=294 width=241) (actual time=0.107..0.503 rows=371 loops=100)"
              Recheck Cond: (((code_id)::text = (stock.code)::text) AND (date >= 'XXXX-XX-XX 00:00:00.331101+00'::timestamp with time zone) AND (date <= 'XXXX-XX-XX 08:08:55.331109+00'::timestamp with time zone))"
              Heap Blocks: exact=37119"
              ->  Bitmap Index Scan on marketdata_code_id_date_e4afd606_idx  (cost=0.00..24.23 rows=294 width=0) (actual time=0.068..0.068 rows=371 loops=100)"
                    Index Cond: (((code_id)::text = (stock.code)::text) AND (date >= 'XXXX-XX-XX 00:00:00.331101+00'::timestamp with time zone) AND (date <= 'XXXX-XX-XX 08:08:55.331109+00'::timestamp with time zone))"
Planning time: 0.704 ms"
Execution time: 135.848 ms"

```

generated by([pev](https://tatiyants.com/pev)）:

![](https://i.imgur.com/okyfgCI.png)



and the "is_special"

```
Sort  (cost=725081.36..725852.57 rows=308485 width=241) (actual time=44276.683..44276.954 rows=1125 loops=1)"
  Sort Key: marketdata.date"
  Sort Method: quicksort  Memory: 250kB"
  ->  Hash Join  (cost=457.44..625254.48 rows=308485 width=241) (actual time=37102.527..44274.947 rows=1125 loops=1)"
        Hash Cond: ((marketdata.code_id)::text = (stock.code)::text)"
        ->  Seq Scan on marketdata  (cost=0.00..619398.55 rows=616970 width=241) (actual time=36321.218..44015.861 rows=783850 loops=1)"
              Filter: ((date >= 'XXXX-XX-XX 00:00:00.331101+00'::timestamp with time zone) AND (date <= 'XXXX-XX-XX 08:08:55.331109+00'::timestamp with time zone))"
              Rows Removed by Filter: 18213401"
        ->  Hash  (cost=441.12..441.12 rows=1306 width=4) (actual time=4.070..4.070 rows=3 loops=1)"
              Buckets: 2048  Batches: 1  Memory Usage: 17kB"
              ->  Seq Scan on stock  (cost=0.00..441.12 rows=1306 width=4) (actual time=4.059..4.064 rows=3 loops=1)"
                    Filter: is_special"
                    Rows Removed by Filter: 2589"
Planning time: 0.692 ms"
Execution time: 44277.220 ms"
```

![](https://i.imgur.com/n9FBnAJ.png)


As you can see, two almost identical queries have vastly different execution times in the database. Both "is_hot" and "is_special" perform sorting at the end. Because the data volume of "is_hot" exceeds the memory limit and quicksort algorithm is used in external merge to sort the data on the hard disk. Whereas the data volume of "is_special" is small and can be completely sorted in memory using quicksort algorithm. Normally, disk operations are much slower than memory operations (hundreds of times slower), so "is_special" should be faster than "is_hot," but the opposite is true in the end. This indicates that there are some time-consuming operations in "is_special" before sorting. Continuing to look down, we will soon discover a particularly time-consuming operation in "is_special". "Seq Scan on marketdata (cost=0.00..619398.55 rows=616970 width=241) (actual time=36321.218..44015.861 rows=783850 loops=1)." This operation will traverse and read the data of the entire table, which according to Postgres' estimate, has 616,970 rows (actually 783,850 rows). It is inevitable that it will take a long time to sequentially traverse such a large table. Ultimately, this operation greatly prolongs the execution time of the entire query. In contrast, in the case of "is_hot," the scan method used for this large table is first a bitmap index scan, followed by a bitmap heap scan, which greatly reduces the query time compared to the first method.

By analyzing this, the root cause of the problem has been narrowed down further. It can be basically determined that the Postgres query planner has a problem and has not found the optimal solution. The next question is, why did the Postgres query planner make this decision?

## 0x03 Further analysis of SQL query planner

Firstly, it can be seen that in the query for is_special, Postgres produced a serious estimation bias for the number of rows with is_special=True in the table (estimated 1306 rows, but only 3 rows actually exist). However, in the is_hot query, Postgres made a correct estimation (estimated 100 rows and there are actually 100 rows).

This estimation error directly caused the estimation time of bitmap heap scan and Nested Loop to be much higher than the actual values. The bitmap heap scan looped 3 times, but with the wrong estimation, it had to loop 1306 times. The Nested Loop went from 3 × 360 × 3 times to 1306 × 360 × 1306 times. As a result, the query planner had to choose another plan that was very time-consuming, but had less estimated time.

Why did Postgres produce such a large estimation bias for the number of rows with is_special=True? This involves how Postgres estimates the number of rows involved in a query. After checking the official Row Estimation documentation, it was found that there is a concept called MCV (most common values) in PG. In short, Postgres collects statistical data about MCV for a column in a view called pg_stats, and uses this data to estimate the number of rows involved in related queries. Following the example in the official documentation, we can look up the statistical data for the is_special column in the stock table.

```
SELECT null_frac, n_distinct, most_common_vals, most_common_freqs
       FROM pg_stats
       WHERE tablename='stock' and attname='is_special';
  
```
return:

```
 null_frac | n_distinct | most_common_vals | most_common_freqs 
-----------+------------+------------------+-------------------
(0 rows)

```
The expected error statistics were not found and a null value was returned, indicating that the database does not have the relevant statistics. This raises two questions:

(1) Who generates the statistics and why are they missing?
(2) If there are no statistics, how did Postgres estimate the number of rows with is_special=True?

Firstly, according to the official documentation, statistics are generated by an Autovacuum Daemon. This daemon is very important as it not only generates statistics but also performs the following tasks:

* To recover or reuse disk space occupied by updated or deleted rows.
* To update the visibility map, which speeds up index-only scans.
* To protect against loss of very old data due to transaction ID wraparound or multixact ID wraparound.

Since these tasks are not directly related to the topic, I will not go into detail here, but they are still very important. In the same document, it is stated that:

For analyze, a similar condition is used: the threshold, defined as:

analyze threshold = analyze base threshold + analyze scale factor * number of tuples

Immediately following this, it is stated that:

The default thresholds and scale factors are taken from postgresql.conf...

In postgresql.conf:

#autovacuum_analyze_threshold = 50 # min number of row updates before analyze
#autovacuum_analyze_scale_factor = 0.1 # fraction of table size before analyze

No wonder there were no relevant statistics, because the threshold had not been reached.

As for the second question, the official documentation does not provide a specific explanation of how row counts are estimated when statistics are not available.

To find out, I had to look into the source code of Postgres. I started from the cost_seqscan function in optimizer/path and traced the functions that use statistics all the way to the booltestsel function in selfuncs.c.

```
/*
 * booltestsel		- Selectivity of BooleanTest Node.
 */
 
Selectivity
booltestsel(PlannerInfo *root, BoolTestType booltesttype, Node *arg,
			int varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)
{

    ...

	else
	{
		/*
		 * If we can't get variable statistics for the argument, perhaps
		 * clause_selectivity can do something with it.  We ignore the
		 * possibility of a NULL value when using clause_selectivity, and just
		 * assume the value is either TRUE or FALSE.
		 */
		switch (booltesttype)
		{
			case IS_UNKNOWN:
				selec = DEFAULT_UNK_SEL;
				break;
			case IS_NOT_UNKNOWN:
				selec = DEFAULT_NOT_UNK_SEL;
				break;
			case IS_TRUE:
			case IS_NOT_FALSE:
				selec = (double) clause_selectivity(root, arg, varRelid, jointype, sjinfo);
				break;
			case IS_FALSE:
			case IS_NOT_TRUE:
				selec = 1.0 - (double) clause_selectivity(root, arg, varRelid, jointype, sjinfo);
				break;
			default:
				elog(ERROR, "unrecognized booltesttype: %d",
					 (int) booltesttype);
				selec = 0.0;	/* Keep compiler quiet */
				break;
		}
	}


```
According to the comments, for boolean values, if the db cannot find statistical information, it will exclude null values and estimate based on the assumption that 50% are trur and 50% are false. Based on the 2598 rows in the stock table, the estimated number of rows with is_special=True should be around 1300. This is consistent with the situation during EXPLAIN ANALYZE.

## 0x04 Solution

According to the documentation, manually analyze the column of the relevant table, force update the data in pg_stats, so that the query planner can make planning based on accurate data. Alternatively, adjust the threshold value for the stock table so that the autovacuum daemon can do the work, which can also solve the problem.

Another approach is to directly tell the query planner the codes involved, so that the query planner does not have to guess, and the optimal solution can be obtained. Personally, I prefer to use this method.  The advantage is that it is easy to migrate, and there is no need to adjust the new postgres when migrating to other databases. Another advantage is to reduce the loading of the query planner, allowing the query planner to find the best execution path more stably.

## 0x05 Reflection

During this debugging process, I spent a considerable amount of time searching for information and conducting various tests, which has led me to gain a much deeper understanding of how postgres operates and can be optimized. One key insight I've discovered is that while the postgres query planner is certainly capable, as programmers we shouldn't rely on it to guess our intentions all the time. By delving into the source code and conducting thorough research, I've been able to gain a much clearer picture of how postgres operates and how it can be optimized to its fullest potential. Overall, this experience has allowed me to shed light on what was once a black box for me, and has given me a much deeper understanding of the intricacies of database optimization.

## Reference

1. https://thoughtbot.com/blog/advanced-postgres-performance-tips
2. https://www.postgresql.org/docs/9.3/row-estimation-examples.html
3. https://gocardless.com/blog/debugging-the-postgres-query-planner
4. https://blog.dbi-services.com/are-statistics-immediately-available-after-creating-a-table-or-an-index-in-postgresql/
5. https://www.postgresql.org/docs/10/routine-vacuuming.html
6. https://docs.mongodb.com/manual/tutorial/analyze-query-plan/
7. https://thoughtbot.com/blog/reading-an-explain-analyze-query-plan
8. https://www.smartly.io/blog/letting-postgresql-plan-well-for-you-markus-winand
9. https://blog.csdn.net/kmblack1/article/details/80761647
10. https://www.cnblogs.com/kissdodog/p/3160560.html
11. https://docs.mongodb.com/manual/core/query-plans/